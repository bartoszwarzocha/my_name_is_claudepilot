---
name: security-vulnerability-assessment
description: Comprehensive security vulnerability assessment with automated scanning, risk prioritization, and remediation planning
tools: [all]
model: claude-sonnet-4
---

# Security Vulnerability Assessment

**Purpose: Conduct comprehensive security vulnerability assessments using automated tools, manual analysis, and strategic risk management to identify, prioritize, and remediate security weaknesses**

## Context Adaptation Framework

Read and understand project specifications from `copilot.instructions.md` file. Adapt all security vulnerability assessment approaches to match:

- **Technology Stack**: Security tools and scanning methodologies for specific languages and frameworks
- **Infrastructure Environment**: Cloud providers, containers, and deployment architectures
- **Compliance Requirements**: Industry standards (PCI DSS, HIPAA, SOC 2, ISO 27001)
- **Business Criticality**: Asset classification and business impact assessment
- **Risk Tolerance**: Organizational security posture and acceptable risk levels
- **Development Lifecycle**: Integration with CI/CD, DevSecOps practices

All security assessments must align with project-specific context while maintaining comprehensive coverage and actionable remediation guidance.

---

## ðŸŽ¯ Mission

Perform systematic security vulnerability assessments that identify, analyze, and prioritize security weaknesses using industry-standard methodologies, providing actionable remediation guidance to strengthen the organization's security posture.

## ðŸ“‹ Comprehensive Security Assessment Framework

### Advanced Vulnerability Scanning Infrastructure

**Multi-Tool Security Pipeline:**
```yaml
# .github/workflows/comprehensive-security-scan.yml
name: Comprehensive Security Assessment

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]
  schedule:
    - cron: '0 2 * * 1'  # Weekly Monday 2 AM
  workflow_dispatch:
    inputs:
      scan_type:
        description: 'Type of security scan'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - sast-only
          - dast-only
          - dependency-only

jobs:
  security-assessment:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        scan-type: [sast, dependency, container, infrastructure, dast]
      fail-fast: false

    steps:
    - name: Checkout Code with Full History
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set Security Environment Variables
      run: |
        echo "SCAN_TIMESTAMP=$(date -u +%Y%m%d_%H%M%S)" >> $GITHUB_ENV
        echo "SCAN_ID=${{ github.run_id }}-${{ matrix.scan-type }}" >> $GITHUB_ENV
        echo "PROJECT_NAME=${{ github.repository }}" >> $GITHUB_ENV

    # SAST (Static Application Security Testing)
    - name: SAST - SemGrep Security Analysis
      if: matrix.scan-type == 'sast' || github.event.inputs.scan_type == 'full'
      run: |
        docker run --rm -v "${PWD}:/src" \
          returntocorp/semgrep:latest \
          --config=auto \
          --config=p/security-audit \
          --config=p/owasp-top-ten \
          --sarif --output=/src/semgrep-results.sarif \
          /src

    - name: SAST - CodeQL Advanced Analysis
      if: matrix.scan-type == 'sast' || github.event.inputs.scan_type == 'full'
      uses: github/codeql-action/init@v3
      with:
        languages: javascript,python,java,csharp
        queries: security-extended,security-and-quality
        config-file: ./.github/codeql/codeql-config.yml

    - name: SAST - Bandit Python Security Scanner
      if: matrix.scan-type == 'sast' || github.event.inputs.scan_type == 'full'
      run: |
        if [ -f requirements.txt ] || [ -f setup.py ] || [ -f pyproject.toml ]; then
          pip install bandit[toml]
          bandit -r . -f sarif -o bandit-results.sarif \
            --severity-level medium \
            --confidence-level medium
        fi

    - name: SAST - ESLint Security Plugin
      if: matrix.scan-type == 'sast' || github.event.inputs.scan_type == 'full'
      run: |
        if [ -f package.json ]; then
          npm install eslint @eslint/js eslint-plugin-security
          npx eslint . --ext .js,.ts,.jsx,.tsx \
            --config .eslintrc-security.js \
            --format json --output-file eslint-security.json
        fi

    # Dependency Vulnerability Scanning
    - name: Dependency - Snyk Open Source Security
      if: matrix.scan-type == 'dependency' || github.event.inputs.scan_type == 'full'
      uses: snyk/actions/node@master
      env:
        SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
      with:
        args: --severity-threshold=medium --sarif --sarif-file-output=snyk-results.sarif

    - name: Dependency - OWASP Dependency Check
      if: matrix.scan-type == 'dependency' || github.event.inputs.scan_type == 'full'
      run: |
        wget -O dependency-check.zip https://github.com/jeremylong/DependencyCheck/releases/download/v8.4.0/dependency-check-8.4.0-release.zip
        unzip dependency-check.zip
        ./dependency-check/bin/dependency-check.sh \
          --project "${{ env.PROJECT_NAME }}" \
          --scan . \
          --format SARIF \
          --out dependency-check-results.sarif \
          --nvdApiKey ${{ secrets.NVD_API_KEY }}

    - name: Dependency - npm audit (if Node.js)
      if: matrix.scan-type == 'dependency' || github.event.inputs.scan_type == 'full'
      run: |
        if [ -f package.json ]; then
          npm audit --audit-level moderate --json > npm-audit-results.json
        fi

    - name: Dependency - pip-audit (if Python)
      if: matrix.scan-type == 'dependency' || github.event.inputs.scan_type == 'full'
      run: |
        if [ -f requirements.txt ] || [ -f setup.py ] || [ -f pyproject.toml ]; then
          pip install pip-audit
          pip-audit --format=sarif --output=pip-audit-results.sarif
        fi

    # Container Security Scanning
    - name: Container - Trivy Security Scanner
      if: matrix.scan-type == 'container' || github.event.inputs.scan_type == 'full'
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-fs-results.sarif'
        severity: 'MEDIUM,HIGH,CRITICAL'

    - name: Container - Docker Image Scanning
      if: matrix.scan-type == 'container' || github.event.inputs.scan_type == 'full'
      run: |
        if [ -f Dockerfile ]; then
          docker build -t security-scan-image .
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
            aquasec/trivy:latest image \
            --format sarif --output /tmp/trivy-image-results.sarif \
            security-scan-image
        fi

    - name: Container - Dockerfile Security Analysis
      if: matrix.scan-type == 'container' || github.event.inputs.scan_type == 'full'
      run: |
        if [ -f Dockerfile ]; then
          docker run --rm -v "${PWD}:/app" \
            hadolint/hadolint:latest \
            hadolint --format sarif /app/Dockerfile > hadolint-results.sarif
        fi

    # Infrastructure Security Scanning
    - name: Infrastructure - Terraform Security (tfsec)
      if: matrix.scan-type == 'infrastructure' || github.event.inputs.scan_type == 'full'
      run: |
        if find . -name "*.tf" -type f | head -1 | grep -q .; then
          docker run --rm -v "${PWD}:/src" \
            aquasec/tfsec:latest \
            --format sarif --out /src/tfsec-results.sarif /src
        fi

    - name: Infrastructure - Checkov Security Analysis
      if: matrix.scan-type == 'infrastructure' || github.event.inputs.scan_type == 'full'
      run: |
        if find . -name "*.tf" -o -name "*.yml" -o -name "*.yaml" | head -1 | grep -q .; then
          pip install checkov
          checkov --directory . \
            --framework terraform,kubernetes,docker \
            --output sarif --output-file checkov-results.sarif
        fi

    - name: Infrastructure - Kubernetes Security (kube-score)
      if: matrix.scan-type == 'infrastructure' || github.event.inputs.scan_type == 'full'
      run: |
        if find . -name "*.yaml" -o -name "*.yml" | xargs grep -l "apiVersion" | head -1 | grep -q .; then
          wget -O kube-score https://github.com/zegl/kube-score/releases/download/v1.16.1/kube-score_1.16.1_linux_amd64.tar.gz
          tar -xzf kube-score
          find . -name "*.yaml" -o -name "*.yml" | xargs grep -l "apiVersion" | \
            xargs ./kube-score score --output-format sarif > kube-score-results.sarif
        fi

    # Setup Application for DAST
    - name: Setup Application for Dynamic Testing
      if: matrix.scan-type == 'dast' || github.event.inputs.scan_type == 'full'
      run: |
        docker-compose -f docker-compose.test.yml up -d
        sleep 30
        curl -f http://localhost:3000/health || exit 1

    # DAST (Dynamic Application Security Testing)
    - name: DAST - OWASP ZAP Baseline Scan
      if: matrix.scan-type == 'dast' || github.event.inputs.scan_type == 'full'
      uses: zaproxy/action-baseline@v0.10.0
      with:
        target: 'http://localhost:3000'
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a -j -l PASS -z "-config scanner.strength=HIGH"'
        allow_issue_writing: false

    - name: DAST - OWASP ZAP Full Scan
      if: matrix.scan-type == 'dast' || github.event.inputs.scan_type == 'full'
      uses: zaproxy/action-full-scan@v0.8.0
      with:
        target: 'http://localhost:3000'
        rules_file_name: '.zap/rules.tsv'
        cmd_options: '-a -j -l PASS'
        allow_issue_writing: false

    - name: DAST - Nikto Web Server Scanner
      if: matrix.scan-type == 'dast' || github.event.inputs.scan_type == 'full'
      run: |
        docker run --rm --network host \
          sullo/nikto:latest \
          -h http://localhost:3000 \
          -Format json -output /tmp/nikto-results.json

    # Advanced Security Analysis
    - name: Advanced - Secret Detection with TruffleHog
      run: |
        docker run --rm -v "${PWD}:/pwd" \
          trufflesecurity/trufflehog:latest \
          filesystem /pwd \
          --json > trufflehog-results.json

    - name: Advanced - License Compliance Check
      run: |
        if [ -f package.json ]; then
          npm install -g license-checker
          license-checker --json > license-check-results.json
        fi

    # Consolidate and Process Results
    - name: Process Security Scan Results
      run: |
        python3 scripts/security-processor.py \
          --scan-id "${{ env.SCAN_ID }}" \
          --scan-type "${{ matrix.scan-type }}" \
          --results-dir . \
          --output consolidated-security-report.json

    # Upload Results
    - name: Upload SARIF Results to GitHub Security
      if: always()
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: '*.sarif'
        category: 'security-assessment-${{ matrix.scan-type }}'

    - name: Upload Detailed Results as Artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: security-results-${{ matrix.scan-type }}-${{ env.SCAN_TIMESTAMP }}
        path: |
          *-results.*
          consolidated-security-report.json
          security-summary.html

    - name: Security Gate Evaluation
      run: |
        python3 scripts/security-gate.py \
          --results-file consolidated-security-report.json \
          --config-file .security/gate-config.yml \
          --fail-on-critical true
```

**Advanced Security Analysis Engine:**
```python
# security-processor.py - Comprehensive security results processor
import json
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Optional
from datetime import datetime
import hashlib
import requests
from dataclasses import dataclass
from enum import Enum

class VulnerabilitySeverity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "informational"

@dataclass
class SecurityVulnerability:
    id: str
    title: str
    description: str
    severity: VulnerabilitySeverity
    cvss_score: float
    cwe_id: Optional[str]
    owasp_category: Optional[str]
    file_path: Optional[str]
    line_number: Optional[int]
    tool_source: str
    remediation_guidance: str
    references: List[str]
    exploitability: str
    business_impact: str

class ComprehensiveSecurityAnalyzer:
    def __init__(self, config_path: str = ".security/analyzer-config.yml"):
        self.config = self.load_configuration(config_path)
        self.vulnerability_database = self.initialize_vuln_db()
        self.risk_calculator = CVSSv3Calculator()
        self.compliance_mapper = ComplianceFrameworkMapper()

    def process_all_security_results(self, results_directory: str) -> Dict[str, Any]:
        """Process all security scan results and generate comprehensive report"""

        print("ðŸ” Processing comprehensive security assessment results...")

        # Process different scan types
        sast_results = self.process_sast_results(results_directory)
        dependency_results = self.process_dependency_results(results_directory)
        container_results = self.process_container_results(results_directory)
        infrastructure_results = self.process_infrastructure_results(results_directory)
        dast_results = self.process_dast_results(results_directory)
        secret_results = self.process_secret_detection_results(results_directory)

        # Consolidate all vulnerabilities
        all_vulnerabilities = self.consolidate_vulnerabilities([
            sast_results,
            dependency_results,
            container_results,
            infrastructure_results,
            dast_results,
            secret_results
        ])

        # Remove duplicates and false positives
        deduplicated_vulnerabilities = self.deduplicate_vulnerabilities(all_vulnerabilities)
        filtered_vulnerabilities = self.filter_false_positives(deduplicated_vulnerabilities)

        # Risk assessment and prioritization
        prioritized_vulnerabilities = self.prioritize_vulnerabilities(filtered_vulnerabilities)

        # Generate comprehensive analysis
        security_analysis = self.generate_security_analysis(prioritized_vulnerabilities)

        # Create executive summary
        executive_summary = self.create_executive_summary(prioritized_vulnerabilities)

        # Compliance mapping
        compliance_report = self.generate_compliance_report(prioritized_vulnerabilities)

        # Remediation planning
        remediation_plan = self.create_remediation_plan(prioritized_vulnerabilities)

        return {
            'scan_metadata': {
                'scan_timestamp': datetime.utcnow().isoformat(),
                'scan_id': self.generate_scan_id(),
                'tools_used': self.get_tools_used(),
                'scan_coverage': self.calculate_scan_coverage()
            },
            'executive_summary': executive_summary,
            'security_analysis': security_analysis,
            'vulnerabilities': prioritized_vulnerabilities,
            'compliance_report': compliance_report,
            'remediation_plan': remediation_plan,
            'metrics': self.calculate_security_metrics(prioritized_vulnerabilities),
            'trends': self.analyze_security_trends(prioritized_vulnerabilities)
        }

    def process_sast_results(self, results_dir: str) -> List[SecurityVulnerability]:
        """Process Static Application Security Testing results"""
        vulnerabilities = []

        # Process SemGrep results
        semgrep_results = self.load_sarif_results(f"{results_dir}/semgrep-results.sarif")
        for result in semgrep_results:
            vuln = SecurityVulnerability(
                id=self.generate_vulnerability_id(result),
                title=result.get('ruleId', 'Unknown Rule'),
                description=result.get('message', {}).get('text', ''),
                severity=self.map_severity(result.get('level', 'info')),
                cvss_score=self.calculate_cvss_from_severity(result.get('level')),
                cwe_id=self.extract_cwe_from_metadata(result),
                owasp_category=self.extract_owasp_category(result),
                file_path=self.extract_file_path(result),
                line_number=self.extract_line_number(result),
                tool_source='semgrep',
                remediation_guidance=self.get_semgrep_remediation(result),
                references=self.extract_references(result),
                exploitability='medium',
                business_impact='medium'
            )
            vulnerabilities.append(vuln)

        # Process CodeQL results
        codeql_results = self.load_sarif_results(f"{results_dir}/codeql-results.sarif")
        for result in codeql_results:
            vuln = SecurityVulnerability(
                id=self.generate_vulnerability_id(result),
                title=result.get('ruleId', 'CodeQL Finding'),
                description=result.get('message', {}).get('text', ''),
                severity=self.map_codeql_severity(result),
                cvss_score=self.calculate_cvss_from_codeql(result),
                cwe_id=self.extract_cwe_from_codeql(result),
                owasp_category=self.map_codeql_to_owasp(result),
                file_path=self.extract_file_path(result),
                line_number=self.extract_line_number(result),
                tool_source='codeql',
                remediation_guidance=self.get_codeql_remediation(result),
                references=self.extract_codeql_references(result),
                exploitability=self.assess_codeql_exploitability(result),
                business_impact=self.assess_business_impact(result)
            )
            vulnerabilities.append(vuln)

        # Process Bandit results (Python)
        bandit_results = self.load_json_results(f"{results_dir}/bandit-results.json")
        for result in bandit_results.get('results', []):
            vuln = SecurityVulnerability(
                id=self.generate_vulnerability_id(result),
                title=f"Bandit {result.get('test_id')}: {result.get('test_name')}",
                description=result.get('issue_text', ''),
                severity=self.map_bandit_severity(result.get('issue_severity')),
                cvss_score=self.calculate_cvss_from_bandit(result),
                cwe_id=self.get_bandit_cwe(result.get('test_id')),
                owasp_category=self.map_bandit_to_owasp(result.get('test_id')),
                file_path=result.get('filename'),
                line_number=result.get('line_number'),
                tool_source='bandit',
                remediation_guidance=self.get_bandit_remediation(result),
                references=[],
                exploitability='medium',
                business_impact='medium'
            )
            vulnerabilities.append(vuln)

        return vulnerabilities

    def process_dependency_results(self, results_dir: str) -> List[SecurityVulnerability]:
        """Process dependency vulnerability scan results"""
        vulnerabilities = []

        # Process Snyk results
        snyk_results = self.load_sarif_results(f"{results_dir}/snyk-results.sarif")
        for result in snyk_results:
            vuln = SecurityVulnerability(
                id=result.get('ruleId', 'SNYK-UNKNOWN'),
                title=f"Vulnerable Dependency: {self.extract_package_name(result)}",
                description=result.get('message', {}).get('text', ''),
                severity=self.map_snyk_severity(result),
                cvss_score=self.extract_cvss_from_snyk(result),
                cwe_id=self.extract_cwe_from_snyk(result),
                owasp_category=self.map_dependency_to_owasp(result),
                file_path=self.extract_dependency_file(result),
                line_number=None,
                tool_source='snyk',
                remediation_guidance=self.get_snyk_remediation(result),
                references=self.extract_snyk_references(result),
                exploitability=self.assess_dependency_exploitability(result),
                business_impact=self.assess_dependency_impact(result)
            )
            vulnerabilities.append(vuln)

        # Process OWASP Dependency Check results
        dependency_check_results = self.load_sarif_results(f"{results_dir}/dependency-check-results.sarif")
        for result in dependency_check_results:
            vuln = SecurityVulnerability(
                id=self.extract_cve_id(result),
                title=f"CVE in Dependency: {self.extract_dependency_name(result)}",
                description=result.get('message', {}).get('text', ''),
                severity=self.map_dependency_check_severity(result),
                cvss_score=self.extract_dependency_cvss(result),
                cwe_id=self.extract_dependency_cwe(result),
                owasp_category='A06:2021 â€“ Vulnerable and Outdated Components',
                file_path=self.extract_dependency_file(result),
                line_number=None,
                tool_source='dependency-check',
                remediation_guidance=self.get_dependency_remediation(result),
                references=self.extract_cve_references(result),
                exploitability=self.assess_cve_exploitability(result),
                business_impact='high'
            )
            vulnerabilities.append(vuln)

        return vulnerabilities

    def process_container_results(self, results_dir: str) -> List[SecurityVulnerability]:
        """Process container security scan results"""
        vulnerabilities = []

        # Process Trivy results
        trivy_results = self.load_sarif_results(f"{results_dir}/trivy-fs-results.sarif")
        for result in trivy_results:
            vuln = SecurityVulnerability(
                id=self.extract_trivy_id(result),
                title=f"Container Vulnerability: {self.extract_trivy_title(result)}",
                description=result.get('message', {}).get('text', ''),
                severity=self.map_trivy_severity(result),
                cvss_score=self.extract_trivy_cvss(result),
                cwe_id=None,
                owasp_category='A06:2021 â€“ Vulnerable and Outdated Components',
                file_path=self.extract_trivy_file(result),
                line_number=None,
                tool_source='trivy',
                remediation_guidance=self.get_trivy_remediation(result),
                references=self.extract_trivy_references(result),
                exploitability='medium',
                business_impact=self.assess_container_impact(result)
            )
            vulnerabilities.append(vuln)

        # Process Hadolint results (Dockerfile security)
        hadolint_results = self.load_sarif_results(f"{results_dir}/hadolint-results.sarif")
        for result in hadolint_results:
            vuln = SecurityVulnerability(
                id=self.generate_vulnerability_id(result),
                title=f"Dockerfile Security Issue: {result.get('ruleId')}",
                description=result.get('message', {}).get('text', ''),
                severity=self.map_hadolint_severity(result),
                cvss_score=self.calculate_dockerfile_cvss(result),
                cwe_id=None,
                owasp_category='A05:2021 â€“ Security Misconfiguration',
                file_path='Dockerfile',
                line_number=self.extract_line_number(result),
                tool_source='hadolint',
                remediation_guidance=self.get_hadolint_remediation(result),
                references=[],
                exploitability='low',
                business_impact='medium'
            )
            vulnerabilities.append(vuln)

        return vulnerabilities

    def process_infrastructure_results(self, results_dir: str) -> List[SecurityVulnerability]:
        """Process infrastructure security scan results"""
        vulnerabilities = []

        # Process tfsec results
        tfsec_results = self.load_sarif_results(f"{results_dir}/tfsec-results.sarif")
        for result in tfsec_results:
            vuln = SecurityVulnerability(
                id=result.get('ruleId', 'TFSEC-UNKNOWN'),
                title=f"Terraform Security Issue: {result.get('ruleId')}",
                description=result.get('message', {}).get('text', ''),
                severity=self.map_tfsec_severity(result),
                cvss_score=self.calculate_infrastructure_cvss(result),
                cwe_id=None,
                owasp_category='A05:2021 â€“ Security Misconfiguration',
                file_path=self.extract_file_path(result),
                line_number=self.extract_line_number(result),
                tool_source='tfsec',
                remediation_guidance=self.get_tfsec_remediation(result),
                references=self.extract_tfsec_references(result),
                exploitability='medium',
                business_impact=self.assess_infrastructure_impact(result)
            )
            vulnerabilities.append(vuln)

        # Process Checkov results
        checkov_results = self.load_sarif_results(f"{results_dir}/checkov-results.sarif")
        for result in checkov_results:
            vuln = SecurityVulnerability(
                id=result.get('ruleId', 'CKV-UNKNOWN'),
                title=f"Infrastructure Misconfiguration: {result.get('ruleId')}",
                description=result.get('message', {}).get('text', ''),
                severity=self.map_checkov_severity(result),
                cvss_score=self.calculate_checkov_cvss(result),
                cwe_id=None,
                owasp_category='A05:2021 â€“ Security Misconfiguration',
                file_path=self.extract_file_path(result),
                line_number=self.extract_line_number(result),
                tool_source='checkov',
                remediation_guidance=self.get_checkov_remediation(result),
                references=[],
                exploitability='medium',
                business_impact=self.assess_checkov_impact(result)
            )
            vulnerabilities.append(vuln)

        return vulnerabilities

    def prioritize_vulnerabilities(self, vulnerabilities: List[SecurityVulnerability]) -> List[Dict[str, Any]]:
        """Advanced vulnerability prioritization using multiple factors"""
        prioritized = []

        for vuln in vulnerabilities:
            # Calculate comprehensive priority score
            priority_score = self.calculate_priority_score(vuln)

            # Assess exploitability
            exploitability_score = self.assess_exploitability(vuln)

            # Determine business impact
            business_impact_score = self.assess_business_impact_advanced(vuln)

            # Calculate remediation effort
            remediation_effort = self.estimate_remediation_effort(vuln)

            # Generate risk rating
            risk_rating = self.calculate_risk_rating(
                priority_score, exploitability_score, business_impact_score
            )

            prioritized_vuln = {
                'vulnerability': vuln.__dict__,
                'priority_score': priority_score,
                'risk_rating': risk_rating,
                'exploitability_assessment': {
                    'score': exploitability_score,
                    'factors': self.get_exploitability_factors(vuln),
                    'threat_actors': self.identify_threat_actors(vuln)
                },
                'business_impact_assessment': {
                    'score': business_impact_score,
                    'affected_assets': self.identify_affected_assets(vuln),
                    'potential_consequences': self.assess_consequences(vuln)
                },
                'remediation_assessment': {
                    'effort': remediation_effort,
                    'complexity': self.assess_remediation_complexity(vuln),
                    'timeline': self.estimate_remediation_timeline(vuln),
                    'dependencies': self.identify_remediation_dependencies(vuln)
                },
                'compliance_impact': self.assess_compliance_impact(vuln)
            }

            prioritized.append(prioritized_vuln)

        # Sort by priority score (highest first)
        return sorted(prioritized, key=lambda x: x['priority_score'], reverse=True)

    def generate_security_analysis(self, prioritized_vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Generate comprehensive security analysis"""

        total_vulns = len(prioritized_vulnerabilities)
        critical_vulns = len([v for v in prioritized_vulnerabilities
                            if v['vulnerability']['severity'] == VulnerabilitySeverity.CRITICAL.value])
        high_vulns = len([v for v in prioritized_vulnerabilities
                         if v['vulnerability']['severity'] == VulnerabilitySeverity.HIGH.value])

        # Calculate overall security posture
        security_posture = self.calculate_security_posture(prioritized_vulnerabilities)

        # Identify attack vectors
        attack_vectors = self.identify_attack_vectors(prioritized_vulnerabilities)

        # Assess compliance gaps
        compliance_gaps = self.assess_compliance_gaps(prioritized_vulnerabilities)

        return {
            'overall_security_posture': security_posture,
            'vulnerability_statistics': {
                'total_vulnerabilities': total_vulns,
                'critical_vulnerabilities': critical_vulns,
                'high_vulnerabilities': high_vulns,
                'medium_vulnerabilities': len([v for v in prioritized_vulnerabilities
                                             if v['vulnerability']['severity'] == VulnerabilitySeverity.MEDIUM.value]),
                'low_vulnerabilities': len([v for v in prioritized_vulnerabilities
                                          if v['vulnerability']['severity'] == VulnerabilitySeverity.LOW.value])
            },
            'attack_vector_analysis': attack_vectors,
            'compliance_analysis': compliance_gaps,
            'trend_analysis': self.analyze_vulnerability_trends(prioritized_vulnerabilities),
            'risk_distribution': self.calculate_risk_distribution(prioritized_vulnerabilities),
            'remediation_overview': self.generate_remediation_overview(prioritized_vulnerabilities)
        }

    def create_executive_summary(self, prioritized_vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Create executive summary for leadership"""

        critical_count = len([v for v in prioritized_vulnerabilities
                            if v['vulnerability']['severity'] == VulnerabilitySeverity.CRITICAL.value])
        high_count = len([v for v in prioritized_vulnerabilities
                         if v['vulnerability']['severity'] == VulnerabilitySeverity.HIGH.value])

        # Determine overall risk level
        if critical_count > 0:
            risk_level = "CRITICAL"
            risk_color = "red"
        elif high_count > 5:
            risk_level = "HIGH"
            risk_color = "orange"
        elif high_count > 0:
            risk_level = "MEDIUM"
            risk_color = "yellow"
        else:
            risk_level = "LOW"
            risk_color = "green"

        return {
            'overall_risk_level': risk_level,
            'risk_level_color': risk_color,
            'total_vulnerabilities_found': len(prioritized_vulnerabilities),
            'critical_vulnerabilities': critical_count,
            'high_priority_vulnerabilities': high_count,
            'immediate_actions_required': self.get_immediate_actions(prioritized_vulnerabilities),
            'business_impact_summary': self.summarize_business_impact(prioritized_vulnerabilities),
            'recommended_timeline': self.recommend_remediation_timeline(prioritized_vulnerabilities),
            'budget_considerations': self.estimate_remediation_costs(prioritized_vulnerabilities),
            'key_recommendations': self.generate_key_recommendations(prioritized_vulnerabilities)
        }

class CVSSv3Calculator:
    """CVSS v3.1 Score Calculator"""

    def __init__(self):
        self.base_metrics = {
            'AV': {'N': 0.85, 'A': 0.62, 'L': 0.55, 'P': 0.2},  # Attack Vector
            'AC': {'L': 0.77, 'H': 0.44},  # Attack Complexity
            'PR': {'N': 0.85, 'L': 0.62, 'H': 0.27},  # Privileges Required
            'UI': {'N': 0.85, 'R': 0.62},  # User Interaction
            'C': {'H': 0.56, 'L': 0.22, 'N': 0},  # Confidentiality
            'I': {'H': 0.56, 'L': 0.22, 'N': 0},  # Integrity
            'A': {'H': 0.56, 'L': 0.22, 'N': 0}   # Availability
        }

    def calculate_base_score(self, metrics: Dict[str, str]) -> float:
        """Calculate CVSS v3.1 base score"""

        # Extract metric values
        av = self.base_metrics['AV'][metrics.get('AV', 'N')]
        ac = self.base_metrics['AC'][metrics.get('AC', 'L')]
        pr = self.base_metrics['PR'][metrics.get('PR', 'N')]
        ui = self.base_metrics['UI'][metrics.get('UI', 'N')]

        c = self.base_metrics['C'][metrics.get('C', 'H')]
        i = self.base_metrics['I'][metrics.get('I', 'H')]
        a = self.base_metrics['A'][metrics.get('A', 'H')]

        # Calculate ISS (Impact Sub Score)
        iss = 1 - ((1 - c) * (1 - i) * (1 - a))

        # Calculate ESS (Exploitability Sub Score)
        ess = 8.22 * av * ac * pr * ui

        # Calculate Base Score
        if iss <= 0:
            base_score = 0.0
        else:
            base_score = min(((iss * ess) + (iss * 6.42)), 10.0)

        return round(base_score, 1)

    def get_severity_rating(self, score: float) -> str:
        """Get severity rating from CVSS score"""
        if score == 0.0:
            return "None"
        elif score <= 3.9:
            return "Low"
        elif score <= 6.9:
            return "Medium"
        elif score <= 8.9:
            return "High"
        else:
            return "Critical"
```

**Security Remediation Planning System:**
```python
# remediation-planner.py
from typing import Dict, List, Any
from datetime import datetime, timedelta
from dataclasses import dataclass

@dataclass
class RemediationTask:
    vulnerability_id: str
    title: str
    priority: str
    estimated_effort: int  # hours
    complexity: str  # low, medium, high
    required_skills: List[str]
    dependencies: List[str]
    business_impact: str
    timeline: str
    assigned_team: str
    status: str

class SecurityRemediationPlanner:
    def __init__(self):
        self.remediation_templates = self.load_remediation_templates()
        self.team_capacity = self.load_team_capacity()
        self.business_windows = self.load_maintenance_windows()

    def create_comprehensive_remediation_plan(self, vulnerabilities: List[Dict]) -> Dict[str, Any]:
        """Create detailed remediation plan with resource allocation"""

        # Categorize vulnerabilities by remediation approach
        immediate_fixes = []
        scheduled_fixes = []
        architectural_changes = []
        policy_updates = []

        for vuln in vulnerabilities:
            remediation_category = self.categorize_remediation(vuln)

            if remediation_category == 'immediate':
                immediate_fixes.append(vuln)
            elif remediation_category == 'scheduled':
                scheduled_fixes.append(vuln)
            elif remediation_category == 'architectural':
                architectural_changes.append(vuln)
            else:
                policy_updates.append(vuln)

        # Create detailed remediation tasks
        all_tasks = []
        all_tasks.extend(self.create_immediate_tasks(immediate_fixes))
        all_tasks.extend(self.create_scheduled_tasks(scheduled_fixes))
        all_tasks.extend(self.create_architectural_tasks(architectural_changes))
        all_tasks.extend(self.create_policy_tasks(policy_updates))

        # Resource allocation and scheduling
        scheduled_tasks = self.allocate_resources_and_schedule(all_tasks)

        # Create timeline and milestones
        timeline = self.create_remediation_timeline(scheduled_tasks)

        return {
            'remediation_summary': {
                'total_vulnerabilities': len(vulnerabilities),
                'immediate_actions': len(immediate_fixes),
                'scheduled_remediations': len(scheduled_fixes),
                'architectural_changes': len(architectural_changes),
                'policy_updates': len(policy_updates),
                'estimated_total_effort': sum(task.estimated_effort for task in all_tasks),
                'expected_completion': self.calculate_completion_date(scheduled_tasks)
            },
            'immediate_action_plan': self.create_immediate_action_plan(immediate_fixes),
            'scheduled_remediation_plan': scheduled_tasks,
            'timeline': timeline,
            'resource_requirements': self.calculate_resource_requirements(all_tasks),
            'risk_mitigation_timeline': self.create_risk_mitigation_timeline(vulnerabilities),
            'success_metrics': self.define_success_metrics(),
            'communication_plan': self.create_communication_plan(all_tasks)
        }

    def create_immediate_action_plan(self, critical_vulns: List[Dict]) -> Dict[str, Any]:
        """Create 24-48 hour immediate action plan"""

        immediate_tasks = []

        for vuln in critical_vulns:
            # Assess if temporary mitigation is possible
            temp_mitigation = self.assess_temporary_mitigation(vuln)

            task = {
                'vulnerability_id': vuln['vulnerability']['id'],
                'title': f"IMMEDIATE: {vuln['vulnerability']['title']}",
                'actions': [
                    'Assess immediate threat and exposure',
                    'Implement temporary mitigation if available',
                    'Monitor for exploitation attempts',
                    'Develop permanent fix plan',
                    'Coordinate with incident response team'
                ],
                'temporary_mitigation': temp_mitigation,
                'monitoring_requirements': self.define_monitoring_requirements(vuln),
                'escalation_criteria': self.define_escalation_criteria(vuln),
                'communication_requirements': self.define_communication_requirements(vuln),
                'success_criteria': [
                    'Temporary mitigation implemented',
                    'Monitoring in place',
                    'Permanent fix plan approved',
                    'Stakeholders notified'
                ],
                'timeline': '24-48 hours',
                'assigned_team': 'Security Incident Response',
                'required_approvals': self.identify_required_approvals(vuln)
            }

            immediate_tasks.append(task)

        return {
            'total_immediate_tasks': len(immediate_tasks),
            'tasks': immediate_tasks,
            'coordination_requirements': self.define_coordination_requirements(critical_vulns),
            'resource_mobilization': self.define_resource_mobilization(),
            'communication_protocol': self.define_emergency_communication_protocol()
        }
```

## ðŸ“Š Advanced Security Metrics and Compliance Framework

**Security Metrics Dashboard:**
```typescript
// security-dashboard.ts
interface SecurityDashboardMetrics {
  vulnerabilityMetrics: {
    totalVulnerabilities: number;
    criticalVulnerabilities: number;
    highVulnerabilities: number;
    mediumVulnerabilities: number;
    lowVulnerabilities: number;
    newVulnerabilitiesThisMonth: number;
    resolvedVulnerabilitiesThisMonth: number;
    averageTimeToRemediation: number;
    vulnerabilityTrends: VulnerabilityTrend[];
  };

  riskMetrics: {
    overallRiskScore: number;
    businessImpactScore: number;
    exploitabilityScore: number;
    riskDistribution: RiskDistribution;
    complianceScore: number;
    securityPosture: SecurityPosture;
  };

  remediationMetrics: {
    remediationBacklog: number;
    overdueRemediations: number;
    remediationVelocity: number;
    teamCapacityUtilization: number;
    costOfRemediation: number;
    preventedSecurityIncidents: number;
  };

  complianceMetrics: {
    owaspTop10Compliance: number;
    cisControlsCompliance: number;
    regulatoryCompliance: ComplianceFramework[];
    auditReadiness: number;
    controlsImplemented: number;
    controlsTotal: number;
  };
}

class SecurityMetricsCollector {
  private metricsHistory: SecurityMetricsHistory[];
  private alertingThresholds: AlertingThresholds;

  constructor() {
    this.initializeMetricsCollection();
    this.setupRealTimeMonitoring();
    this.configureAlerting();
  }

  async collectComprehensiveMetrics(): Promise<SecurityDashboardMetrics> {
    const vulnerabilityData = await this.collectVulnerabilityMetrics();
    const riskData = await this.collectRiskMetrics();
    const remediationData = await this.collectRemediationMetrics();
    const complianceData = await this.collectComplianceMetrics();

    return {
      vulnerabilityMetrics: vulnerabilityData,
      riskMetrics: riskData,
      remediationMetrics: remediationData,
      complianceMetrics: complianceData
    };
  }

  private async collectVulnerabilityMetrics(): Promise<any> {
    // Collect vulnerability metrics from multiple sources
    const scanResults = await this.aggregateScanResults();
    const trends = await this.calculateVulnerabilityTrends();

    return {
      totalVulnerabilities: scanResults.total,
      criticalVulnerabilities: scanResults.critical,
      highVulnerabilities: scanResults.high,
      mediumVulnerabilities: scanResults.medium,
      lowVulnerabilities: scanResults.low,
      newVulnerabilitiesThisMonth: trends.newThisMonth,
      resolvedVulnerabilitiesThisMonth: trends.resolvedThisMonth,
      averageTimeToRemediation: trends.avgRemediationTime,
      vulnerabilityTrends: trends.historical
    };
  }

  async generateExecutiveReport(): Promise<ExecutiveSecurityReport> {
    const metrics = await this.collectComprehensiveMetrics();

    return {
      executiveSummary: {
        overallSecurityPosture: this.calculateOverallPosture(metrics),
        keyFindings: this.identifyKeyFindings(metrics),
        immediateActions: this.identifyImmediateActions(metrics),
        budgetImplications: this.calculateBudgetImplications(metrics),
        complianceStatus: this.assessComplianceStatus(metrics)
      },
      riskAnalysis: {
        topRisks: this.identifyTopRisks(metrics),
        riskTrends: this.analyzeRiskTrends(metrics),
        businessImpact: this.assessBusinessImpact(metrics)
      },
      recommendations: {
        strategicRecommendations: this.generateStrategicRecommendations(metrics),
        tacticalActions: this.generateTacticalActions(metrics),
        investmentPriorities: this.prioritizeInvestments(metrics)
      },
      complianceReport: {
        regulatoryStatus: this.assessRegulatoryCompliance(metrics),
        auditReadiness: this.assessAuditReadiness(metrics),
        remedialActions: this.identifyComplianceGaps(metrics)
      }
    };
  }
}
```

## ðŸ“¤ Comprehensive Deliverables

**Security Assessment Package:**
- **Executive Security Report** with business risk analysis and strategic recommendations
- **Technical Vulnerability Report** with detailed findings and remediation guidance
- **Compliance Assessment** mapping vulnerabilities to regulatory frameworks
- **Risk Prioritization Matrix** with business impact and exploitability analysis
- **Remediation Roadmap** with timeline, resource allocation, and success metrics
- **Security Metrics Dashboard** with real-time monitoring and alerting
- **Incident Response Procedures** for vulnerability management and escalation

**Automated Security Infrastructure:**
- **CI/CD Security Pipeline** with comprehensive scanning and quality gates
- **Security Tool Integration** for continuous vulnerability assessment
- **Alerting and Notification System** for new vulnerability discovery
- **Compliance Monitoring Framework** for regulatory requirement tracking
- **Security Knowledge Base** with vulnerability patterns and remediation guides

---

## Transition to Implementation

**Next Steps:**
Based on the comprehensive security vulnerability assessment framework, consider switching to specialized chatmodes for implementation:

- Switch to **security-engineer** chatmode to implement specific security controls and remediation measures
- Switch to **deployment-engineer** chatmode to integrate security scanning into CI/CD pipelines
- Switch to **backend-engineer** or **frontend-engineer** chatmodes to implement security fixes and hardening
- Switch to **business-analyst** chatmode to communicate security risks and business impact to stakeholders

*Comprehensive security vulnerability assessment ensures proactive identification, prioritization, and remediation of security risks through systematic analysis, strategic planning, and continuous improvement.*